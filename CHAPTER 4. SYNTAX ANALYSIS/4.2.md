### 4.2.1
***
Consider the context-free grammar:
```
S -> S S + | S S * | a
```
and the string *aa*+*a**.

a) Give a leftmost derivation for the string.

b) Give a rightmost derivation for the string.

c) Give a parse tree for the string.

d) Is the grammar ambiguous or unambiguous? Justify your answer.

e) Describe the language generated by this grammar.

### `Answer`
a) ```S =lm=> SS* =lm=> SS+S* =lm=> aS+S* =lm=> aa+S* =lm=> aa+a*```

b) ```S =rm=> SS* =rm=> Sa* =rm=> SS+a* =rm=> Sa+a* =rm=> aa+a*```

d) The grammar is unambiguous

e) The language generated by this grammar is the set of all postfix expressions consisting of addition and multiplication operators

### 4.2.2
***
Repeat Exercise 4.2.1 for each of the following grammars and strings:

a) ```S -> 0 S 1 | 0 1``` with string ```000111```.

b) ```S -> + S S | * S S | a``` with string +**aaa*.

c) ```S -> S ( S ) S | ε``` with string (()()).

d) ```S -> S + S | S S | ( S ) | S * | a``` with string (*a*+*a*)**a*.

e) ```S -> ( L ) | a``` and ```L -> L , S | S``` with string ((*a*, *a*), *a*, (*a*)).

f) ```S -> a S b S | b S a S | ε``` with string *aabbab*.

g) The following grammar for boolean expressions:
```
  bexpr -> bexpr or bterm | bterm
  bterm -> bterm and bfactor | bfactor
bfactor -> not bfactor | ( bexpr ) | true | false
```

### `Answer`
a)

a) ```S =lm=> 0S1 =lm=> 00S11 =lm=> 000111```

b) ```S =rm=> 0S1 =rm=> 00S11 =rm=> 000111```

d) The grammar is unambiguous

e) The language generated by this grammar is equal number of 0s followed by equal number of 1s

b)

a) ```S =lm=> +SS =lm=> +*SSS =lm=> +*aSS =lm=> +*aaS =lm=> +*aaa```

b) ```S =rm=> +SS =rm=> +Sa =rm=> +*SSa =rm=> +*Saa =rm=> +*aaa```

d) The grammar is unambiguous

e) The language generated by this grammar is the set of all prefix expressions consisting of addition and multiplication operators

c)

a) ```S =lm=> S(S)S =lm=> (S)S =lm=> (S(S)S)S =lm=> ((S)S)S =lm=> (()S)S =lm=> (()S(S)S)S =lm=> (()(S)S)S =lm=> (()()S)S =lm=> (()())S =lm=> (()())```

b) ```S =rm=> S(S)S =rm=> S(S) =rm=> S(S(S)S) =rm=> S(S(S)) =rm=> S(S()) =rm=> S(S(S)S()) =rm=> S(S(S)()) =rm=> S(S()()) =rm=> S(()()) =rm=> (()())```

d) The grammar is ambiguous

e) The language generated by this grammar is the set of all strings of symmetrical parenthesis

d)

a) ```S =lm=> SS =lm=> S*S =lm=> (S)*S =lm=> (S+S)*S =lm=> (a+S)*S =lm=> (a+a)*S =lm=> (a+a)*a```

b) ```S =rm=> SS =rm=> Sa =rm=> S*a =rm=> (S)*a =rm=> (S+S)*a =rm=> (S+a)*a =rm=> (a+a)*a```

d) The grammar is ambiguous

e) The language generated by this grammar is the set of all infix expressions consisting of addition and multiplication operators

e)

a) ```S =lm=> (L) =lm=> (L, S) =lm=> (L, S, S) =lm=> (S, S, S) =lm=> ((L), S, S) =lm=> ((L, S), S, S) =lm=> ((S, S), S, S) =lm=> ((a, S), S, S) =lm=> ((a, a), S, S) =lm=> ((a, a), a, S) =lm=> ((a, a), a, (L)) =lm=> ((a, a), a, (a))```

b) ```S =rm=> (L) =rm=> (L, S) =rm=> (L, (L)) =rm=> (L, (S)) =rm=> (L, (a)) =rm=> (L, S, (a)) =rm=> (L, a, (a)) =rm=> (S, a, (a)) =rm=> ((L), a, (a)) =rm=> ((L, S), a, (a)) =rm=> ((L, a), a, (a)) =rm=> ((S, a), a, (a)) =rm=> ((a, a), a, (a))```

d) The grammar is unambiguous

f)

a) ```S =lm=> aSbS =lm=> aaSbSbS =lm=> aabSbS =lm=> aabbS =lm=> aabbaSbS =lm=> aabbabS =lm=> aabbab```

b) ```S =rm=> aSbS =rm=> aSb =rm=> aaSbSb =rm=> aaSbbSaSb =rm=> aaSbbSab =rm=> aaSbbab =rm=> aabbab```

d) The grammar is ambiguous

g)

d) The grammar is unambiguous

### 4.2.3
***
Design grammars for the following languages:

a) The set of all strings of 0s and 1s such that every 0 is immediately followed by at least one 1.

b) The set of all strings of 0s and 1s that are *palindromes*; that is the string reads the same backward as forward.

c) The set of all strings of 0s and 1s with an equal number of 0s and 1s.

d) The set of all strings of 0s and 1s with an unequal number of 0s and 1s.

e) The set of all strings of 0s and 1s in which 011 does not appear as a substring.

f) The set of all strings of 0s and 1s of the form *xy*, where *x* ≠ *y* and *x* and *y* are of the same length.

### `Answer`
a) ```S -> 0 1 S | 1 S | ε```

b) ```S -> 0 S 0 | 1 S 1 | 0 | 1 | ε```

c) ```S -> 0 S 1 S | 1 S 0 S | ε```

d)
```
S -> A | B
A -> C | CA
B -> D | DB
C -> 0 C C | 1 E
D -> 0 E | 1 D D
E -> 0 C | 1 D | ε
```

e) 
```
S -> 1 S | 0 A | ε
A -> 0 A | 1 B | ε
B -> 0 A | ε
```

f)
```
S -> A B | B A
A -> 0 A 0 | 0 A 1 | 1 A 0 | 1 A 1 | 0
B -> 0 B 0 | 0 B 1 | 1 B 0 | 1 B 1 | 1
```

### 4.2.4
***
There is an extended grammar notation in common use. In this notation, square and curly braces in production bodies are metasymbols (like -> or |) with the following meanings:

*i*) Square braces around a grammar symbol or symbols denotes that these constructs are optional. Thus, production ```A -> X [Y] Z``` has the same effect as the two productions ```A -> X Y Z``` and ```A -> X Z```.

*ii*) Curly braces around a grammar symbol or symbols says that these symbols may be repeated any number of times, including zero times. Thus, ```A -> X```, ```A -> X Y Z```, ```A -> X Y Z Y Z```, and so on.

Show that these two extensions do not add power to grammars; that is, any language that can be generated by a grammar with these extensions can be generated without the extensions.

### `Answer`
*i*) ```A -> X [Y] Z``` can be written as ```A -> X Y Z | X Z```

*ii*) ```A -> X {Y Z}``` can be written as
```
A -> X B
B -> Y Z B | ε
```

### 4.2.5
***
Use the braces described in Exercise 4.2.4 to simplify the following grammar for statement blocks and conditional statements:
```
    stmt -> if expr then stmt else stmt
          | if expr then stmt
          | begin stmtList end
stmtList -> stmt ; stmtList | stmt
```

### `Answer`
```
    stmt -> if expr then stmt [else stmt]
          | begin stmtList end
stmtList -> stmt [; stmtList]
```
